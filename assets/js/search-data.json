{
  
    
        "post0": {
            "title": "Speeding up fastai Tabular with NumPy",
            "content": "What is fastai Tabular? A TL;DR . When working with tabular data, fastai has introduced a powerful tool to help with prerocessing your data: TabularPandas. It&#39;s super helpful and useful as you can have everything in one place, encode and decode all of your tables at once, and the memory usage on top of your Pandas dataframe can be very minimal. Let&#39;s look at an example of it. . First let&#39;s import the tabular module: . from fastai2.tabular.all import * . For our particular tests today, we&#39;ll be using the ADULT_SAMPLE dataset, where we need to identify if a particular individual makes above or below $50,000. Let&#39;s grab the data: . path = untar_data(URLs.ADULT_SAMPLE) . And now we can open it in Pandas: . df = pd.read_csv(path/&#39;adult.csv&#39;) . df.head() . age workclass fnlwgt education education-num marital-status occupation relationship race sex capital-gain capital-loss hours-per-week native-country salary . 0 49 | Private | 101320 | Assoc-acdm | 12.0 | Married-civ-spouse | NaN | Wife | White | Female | 0 | 1902 | 40 | United-States | &gt;=50k | . 1 44 | Private | 236746 | Masters | 14.0 | Divorced | Exec-managerial | Not-in-family | White | Male | 10520 | 0 | 45 | United-States | &gt;=50k | . 2 38 | Private | 96185 | HS-grad | NaN | Divorced | NaN | Unmarried | Black | Female | 0 | 0 | 32 | United-States | &lt;50k | . 3 38 | Self-emp-inc | 112847 | Prof-school | 15.0 | Married-civ-spouse | Prof-specialty | Husband | Asian-Pac-Islander | Male | 0 | 0 | 40 | United-States | &gt;=50k | . 4 42 | Self-emp-not-inc | 82297 | 7th-8th | NaN | Married-civ-spouse | Other-service | Wife | Black | Female | 0 | 0 | 50 | United-States | &lt;50k | . Now that we have our DataFrame, let&#39;s fit it into a TabularPandas object for preprocessing. To do so, we need to decalre the following: . procs (pre-processing our data, such as normalization and converting categorical values to numbers) | cat_names (categorical variables) | cont_names (continuous variables) | y_names (our y columns) | . For our case, these look like so: . cat_names = [&#39;workclass&#39;, &#39;education&#39;, &#39;marital-status&#39;, &#39;occupation&#39;, &#39;relationship&#39;, &#39;race&#39;] cont_names = [&#39;age&#39;, &#39;fnlwgt&#39;, &#39;education-num&#39;] procs = [Categorify, FillMissing, Normalize] y_names = &#39;salary&#39; . We&#39;ll also need to tell TabularPandas how we want to split our data. We&#39;ll use a random 20% subsample: . splits = RandomSplitter()(range_of(df)) . Now let&#39;s make a TabularPandas! . to = TabularPandas(df, procs=procs, cat_names=cat_names, cont_names=cont_names, y_names=y_names, splits=splits) . Now all of our data is pre-processed here and we can grab all of the raw values if we wanted to say use it with XGBoost like so: . to.train.xs.iloc[:3] . workclass education marital-status occupation relationship race education-num_na age fnlwgt education-num . 3337 8 | 13 | 5 | 11 | 2 | 2 | 1 | -1.071338 | -0.396740 | 1.532950 | . 13162 8 | 12 | 3 | 12 | 1 | 5 | 1 | 0.030019 | 0.469650 | -0.417817 | . 10215 5 | 10 | 1 | 5 | 2 | 5 | 1 | -0.557371 | 0.392678 | 1.142797 | . Andi it&#39;s fully encoded! Now that we&#39;re a bit familiar with TabularPandas, let&#39;s do some speed tests! . The Baseline . For our tests, we&#39;ll run 4 different tests: . One batch of the training data | Iterating over the entire training dataset | Iterating over the entire validation set | Fitting for 10 epochs (GPU only) | And for each of these we will compare the times on the CPU and the GPU. . CPU: . First let&#39;s grab the first batch. The reason this is important is each time we iterate over the training DataLoader, we actually shuffle our data, which can add some time: . dls = to.dataloaders(bs=128, device=&#39;cpu&#39;) . To test our times, we&#39;ll use %%timeit. It measures the execution time of a Python function for a certain amount of loops, and reports back the fastest one. For iterating over the entire DataLoader we&#39;ll look at the time per batch as well. . First, a batch from training: . %%timeit _ = next(iter(dls.train)) . 10 loops, best of 3: 18.3 ms per loop . Now the validation: . %%timeit _ = next(iter(dls.valid)) . 100 loops, best of 3: 3.37 ms per loop . Alright, so first we can see that our shuffling function is adding almost 15 milliseconds on our time, something we can improve on! Let&#39;s then go through the entire DataLoader: . %%timeit for _ in dls.train: _ . 1 loop, best of 3: 661 ms per loop . Now let&#39;s get an average time per batch: . print(661/len(dls.train)) . 3.2561576354679804 . About 3.25 milliseconds per batch on the training dataset, let&#39;s look at the validation: . %%timeit for _ in dls.valid: _ . 10 loops, best of 3: 159 ms per loop . print(159/len(dls.valid)) . 3.1176470588235294 . And about 3.11 milliseconds per batch on the validation, so we can see that it&#39;s about the same after shuffling. Now let&#39;s compare some GPU times: . GPU . dls = to.dataloaders(bs=128, device=&#39;cuda&#39;) . %%timeit _ = next(iter(dls.train)) . 100 loops, best of 3: 18.8 ms per loop . %%timeit _ = next(iter(dls.valid)) . 100 loops, best of 3: 3.49 ms per loop . So first, grabbing just one batch we can see it added about a half a millisecond on the training and .2 milliseconds on the validation, so we&#39;re not utilizing the GPU for this process much (which makes sense, TabularPandas is CPU bound). And now let&#39;s iterate: . %%timeit for _ in dls.train: _ . 1 loop, best of 3: 693 ms per loop . print(693/len(dls.train)) . 3.413793103448276 . %%timeit for _ in dls.valid: _ . 10 loops, best of 3: 163 ms per loop . print(163/len(dls.valid)) . 3.196078431372549 . And here we can see a little bit more being added here as well. Now that we have those baselines, let&#39;s fit for ten epochs real quick: . learn = tabular_learner(dls, layers=[200,100], metrics=accuracy) . %%time learn.fit(10, 1e-2) . epoch train_loss valid_loss accuracy time . 0 | 0.377574 | 0.364423 | 0.833999 | 00:02 | . 1 | 0.356772 | 0.357792 | 0.835688 | 00:02 | . 2 | 0.358388 | 0.358207 | 0.833692 | 00:02 | . 3 | 0.352414 | 0.352521 | 0.840602 | 00:02 | . 4 | 0.349441 | 0.350070 | 0.840756 | 00:02 | . 5 | 0.347263 | 0.358235 | 0.841370 | 00:02 | . 6 | 0.346777 | 0.352908 | 0.838606 | 00:02 | . 7 | 0.352095 | 0.352776 | 0.839681 | 00:02 | . 8 | 0.347428 | 0.348187 | 0.840909 | 00:02 | . 9 | 0.346684 | 0.352819 | 0.835074 | 00:02 | . CPU times: user 22.2 s, sys: 263 ms, total: 22.4 s Wall time: 22.9 s . After fitting, we got about 22.9 seconds in total and ~2.29 seconds per epoch! Now that we have our baselines, let&#39;s try to speed that up! . Bringing in NumPy . The Dataset . With speeding everything up, I wanted to keep TabularPandas as it is, as it&#39;s a great way to pre-process your data! So instead we&#39;ll create a new Dataset class where we will convert our TabularPandas object into a NumPy array. Why is that important? NumPy is a super-fast library that has been hyper-optimized by using as much C code as it possibly can which is leagues faster than Python. Let&#39;s build our Dataset! . We&#39;ll want it to maintain the cats, conts, and ys from our TabularPandas object seperate. We can call to_numpy() on all of them because they are simply stored as a DataFrame! Finally, to deal with categorical versus continuous variables, we&#39;ll assign our cats as np.long and our conts as np.float32 (we also have our ys as np.int8, but this is because we&#39;re doing classification): . class TabDataset(): &quot;A `NumPy` dataset from a `TabularPandas` object&quot; def __init__(self, to): self.cats = to.cats.to_numpy().astype(np.long) self.conts = to.conts.to_numpy().astype(np.float32) self.ys = to.ys.to_numpy() . Great! Now we need a few more bits for everything to work! For our Dataset to function, we need to be able to gather the values from it each time we call from it. We use the __getitem__ function to do so! For our particular problem, we need it to return some cats, conts, and our ys. And to save on more time we&#39;ll return a whole batch of values: . class TabDataset(): &quot;A `NumPy` dataset from a `TabularPandas` object&quot; def __init__(self, to): self.cats = to.cats.to_numpy().astype(np.long) self.conts = to.conts.to_numpy().astype(np.float32) self.ys = to.ys.to_numpy() def __getitem__(self, idx): idx = idx[0] return self.cats[idx:idx+self.bs], self.conts[idx:idx+self.bs], self.ys[idx:idx+self.bs] . You&#39;ll notice we don&#39;t explicitly pass in a batch size, so where is that coming from? This is added when we build our DataLoader, as we&#39;ll see later. Let&#39;s finish up our Dataset class by adding in an option to get the length of the dataset (we&#39;ll do the length of our categorical table in this case). . class TabDataset(): &quot;A `NumPy` dataset from a `TabularPandas` object&quot; def __init__(self, to): self.cats = to.cats.to_numpy().astype(np.long) self.conts = to.conts.to_numpy().astype(np.float32) self.ys = to.ys.to_numpy() def __getitem__(self, idx): idx = idx[0] return self.cats[idx:idx+self.bs], self.conts[idx:idx+self.bs], self.ys[idx:idx+self.bs] def __len__(self): return len(self.cats) . And now we can make some Datasets! . train_ds = TabDataset(to.train) valid_ds = TabDataset(to.valid) . We can look at some data real quick if we want to as well! First we need to assign a batch size: . train_ds.bs = 3 . And now let&#39;s look at some data: . train_ds[[3]] . (array([[ 5, 10, 5, 5, 2, 5, 1], [ 2, 16, 3, 5, 1, 3, 1], [ 5, 16, 3, 5, 1, 5, 1]]), array([[-0.9979143 , 0.07715245, 1.1427965 ], [ 0.8376807 , 1.4486277 , -0.02766372], [ 1.4984949 , -1.4280752 , -0.02766372]], dtype=float32), array([[0], [0], [1]], dtype=int8)) . We can see that we output what could be considered a batch of data! The only thing missing is to make it into a tensor! Fantastic! Now let&#39;s build the DataLoader, as there&#39;s some pieces in it that we need, so simply having this Dataset won&#39;t be enough . The DataLoader . Now to build our DataLoader, we&#39;re going to want to modify 4 particular functions: . create_item | create_batch | get_idxs | shuffle_ds | Each of these play a particular role. First let&#39;s look at our template: . class TabDataLoader(DataLoader): def __init__(self, dataset, bs=1, num_workers=0, device=&#39;cuda&#39;, shuffle=False, **kwargs): &quot;A `DataLoader` based on a `TabDataset`&quot; super().__init__(dataset, bs=bs, num_workers=num_workers, shuffle=shuffle, device=device, drop_last=shuffle, **kwargs) self.dataset.bs=bs . As you can see, our __init__ will build a DataLoader, and we keep track of our Dataset and set the Datasets batch size here as well . dl = TabDataLoader(train_ds, bs=3) . dl.dataset.bs . 3 . dl.dataset[[0]] . (array([[ 8, 13, 5, 11, 2, 2, 1], [ 8, 12, 3, 12, 1, 5, 1], [ 5, 10, 1, 5, 2, 5, 1]]), array([[-1.071338 , -0.39674038, 1.5329499 ], [ 0.03001888, 0.46965045, -0.41781712], [-0.5573715 , 0.39267784, 1.1427965 ]], dtype=float32), array([[0], [0], [0]], dtype=int8)) . And we can see that we grab everything as normal in the Dataset! Great! Now let&#39;s work on create_item and create_batch. create_item is very simple as we already do so when we make our call to the dataset, so we just pass it on. create_batch is also very simplistic. We&#39;ll take some index&#39;s from our Dataset and convert them all to Tensors! . class TabDataLoader(DataLoader): def __init__(self, dataset, bs=1, num_workers=0, device=&#39;cuda&#39;, shuffle=False, **kwargs): &quot;A `DataLoader` based on a `TabDataset`&quot; super().__init__(dataset, bs=bs, num_workers=num_workers, shuffle=shuffle, device=device, drop_last=shuffle, **kwargs) self.dataset.bs=bs def create_item(self, s): return s def create_batch(self, b): cat, cont, y = self.dataset[b] return tensor(cat).to(self.device), tensor(cont).to(self.device), tensor(y).to(self.device) . Now we&#39;re almost done. The last two pieces missing is get_idxs and shuffle_fn. These are needed as after each epoch we actually shuffle the dataset and we need to get a list of index&#39;s for our DataLoader to use! To save on time (as we’re using array indexing), we can shuffle the interior dataset instead! A major benefit is slicing (consecutive idxs) instead of indexing (non-consecutive idxs). Let&#39;s look at what that looks like: . class TabDataLoader(DataLoader): def __init__(self, dataset, bs=1, num_workers=0, device=&#39;cuda&#39;, shuffle=False, **kwargs): &quot;A `DataLoader` based on a `TabDataset`&quot; super().__init__(dataset, bs=bs, num_workers=num_workers, shuffle=shuffle, device=device, drop_last=shuffle, **kwargs) self.dataset.bs=bs def create_item(self, s): return s def create_batch(self, b): &quot;Create a batch of data&quot; cat, cont, y = self.dataset[b] return tensor(cat).to(self.device), tensor(cont).to(self.device), tensor(y).to(self.device) def get_idxs(self): &quot;Get index&#39;s to select&quot; idxs = Inf.count if self.indexed else Inf.nones if self.n is not None: idxs = list(range(len(self.dataset))) return idxs def shuffle_fn(self): &quot;Shuffle the interior dataset&quot; rng = np.random.permutation(len(self.dataset)) self.dataset.cats = self.dataset.cats[rng] self.dataset.conts = self.dataset.conts[rng] self.dataset.ys = self.dataset.ys[rng] . And now we have all the pieces we need to build a DataLoader with NumPy! We&#39;ll examine it&#39;s speed now and then we&#39;ll build some convience functions later. First let&#39;s build the Datasets: . train_ds = TabDataset(to.train) valid_ds = TabDataset(to.valid) . And then the DataLoader: . train_dl = TabDataLoader(train_ds, device=&#39;cpu&#39;, shuffle=True, bs=128) valid_dl = TabDataLoader(valid_ds, device=&#39;cpu&#39;, bs=128) . And now let&#39;s grab some CPU timings similar to what we did before: . %%timeit _ = next(iter(train_dl)) . 1000 loops, best of 3: 669 µs per loop . %%timeit _ = next(iter(valid_dl)) . 1000 loops, best of 3: 300 µs per loop . Right away we can see that we are leagues faster than the previous version. Shuffling only added ~370 microseconds, which means we used 4% of the time! Now let&#39;s iterate over the entire DataLoader: . %%timeit for _ in train_dl: _ . 10 loops, best of 3: 31.8 ms per loop . print(31.8/len(train_dl)) . 0.1566502463054187 . %%timeit for _ in valid_dl: _ . 100 loops, best of 3: 8.07 ms per loop . print(8.07/len(valid_dl)) . 0.15823529411764706 . And as we can see, each individual batch of data is about 0.158 milliseconds! Yet again, about 6% of time time, quite a decrease! So we have sucessfully decreased the time! Let&#39;s look at the GPU now: . train_dl = TabDataLoader(train_ds, device=&#39;cuda&#39;, shuffle=True, bs=128) valid_dl = TabDataLoader(valid_ds, device=&#39;cuda&#39;, bs=128) . %%timeit _ = next(iter(train_dl)) . 1000 loops, best of 3: 835 µs per loop . %%timeit _ = next(iter(valid_dl)) . 1000 loops, best of 3: 451 µs per loop . %%timeit for _ in train_dl: _ . 10 loops, best of 3: 51.5 ms per loop . print(51.5/len(train_dl)) . 0.2536945812807882 . %%timeit for _ in valid_dl: _ . 100 loops, best of 3: 12.8 ms per loop . print(12.8/len(valid_dl)) . 0.25098039215686274 . Which as we can see, it adds a little bit of time from converting the tensors over to cuda. You could save a little bit more by converting first, but as this should be seperate from the dataset I decided to just keep it here. Now that we have all the steps, finally we can take a look at training! First let&#39;s build a quick helper function to make DataLoaders similar to what fastai&#39;s tabular_learner would be expecting: . class TabDataLoaders(DataLoaders): def __init__(self, to, bs=64, val_bs=None, shuffle_train=True, device=&#39;cpu&#39;, **kwargs): train_ds = TabDataset(to.train) valid_ds = TabDataset(to.valid) val_bs = bs if val_bs is None else val_bs train = TabDataLoader(train_ds, bs=bs, shuffle=shuffle_train, device=device, **kwargs) valid = TabDataLoader(valid_ds, bs=val_bs, shuffle=False, device=device, **kwargs) super().__init__(train, valid, device=device, **kwargs) . dls = TabDataLoaders(to, bs=128, device=&#39;cuda&#39;) . And now we can build our model and train! We need to build our own TabularModel here, so we&#39;ll need to grab the size of our embeddings and build a Learner. For simplicity we&#39;ll still use TabularPandas to get those sizes: . emb_szs = get_emb_sz(to) net = TabularModel(emb_szs, n_cont=3, out_sz=2, layers=[200,100]).cuda() learn = Learner(dls, net, metrics=accuracy, loss_func=CrossEntropyLossFlat()) . And now let&#39;s train! . %%time learn.fit(10, 1e-2) . epoch train_loss valid_loss accuracy time . 0 | 0.369785 | 0.358381 | 0.837531 | 00:01 | . 1 | 0.359938 | 0.354405 | 0.840602 | 00:01 | . 2 | 0.353965 | 0.354380 | 0.837838 | 00:01 | . 3 | 0.350551 | 0.355998 | 0.837684 | 00:01 | . 4 | 0.349042 | 0.357085 | 0.838606 | 00:01 | . 5 | 0.347858 | 0.354116 | 0.839988 | 00:01 | . 6 | 0.344613 | 0.352649 | 0.840448 | 00:01 | . 7 | 0.343187 | 0.351604 | 0.840909 | 00:01 | . 8 | 0.342587 | 0.353344 | 0.841523 | 00:01 | . 9 | 0.342127 | 0.355749 | 0.841216 | 00:01 | . CPU times: user 13.4 s, sys: 203 ms, total: 13.6 s Wall time: 13.8 s . As you can see, we cut the speed down 60%! So we saw a tremendous speed up! Let&#39;s quickly revisit all of the times and results in a pretty table. . Results . CPU? First Batch Per Batch Per Epoch Ten Epochs . fastai2 | Yes | 18.3ms (train) 3.37ms (valid) | 3.25ms (train) 3.11ms (valid) | | | . | No | 18.8ms (train) 3.49ms (valid) | 3.41ms (train) 3.19ms (valid) | 2.29s | 22.9s | . NumPy | Yes | 0.669ms (train) 0.3ms (valid | 0.15ms (train) 0.15ms (valid) | | | . | No | 0.835ms (train) 0.451ms (valid) | 0.25ms (train) 0.25ms (valid) | 1.38s | 13.8s | . So in summary, we first sped up the time to grab a single batch of data by converting everything from Pandas to NumPy. Afterwards we made a custom DataLoader that could handle these NumPy arrays and induce the speedup we saw! I hope this article helps you better understand how the interior DataLoader can be integrated in with NumPy, and that it helps you speed up your tabular training! . Small note: show_batch() etc will not work with this particular code base, this is simply a proof of concept | .",
            "url": "https://muellerzr.github.io/fastblog/2020/04/22/TabularNumpy.html",
            "relUrl": "/2020/04/22/TabularNumpy.html",
            "date": " • Apr 22, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Coral Species Identification with fastai, a Paper Comparison",
            "content": ". This blog is also a Jupyter notebook available to run from the top down. There will be code snippets that you can then run in any Jupyter environment. This post was written using: . fastai2: 0.0.13 . | fastcore: 0.1.15 . | . . What is this series? . This new series of blogs will be focused on implementing various papers and attempting to beat benchmarks with the tools and techniques Fast.AI teaches. The paper we will be focusing on for this first part is Coral species identification with texture or structure images using a two-level classifier based on Convolutional Neural Networks by Gomez-Rios, Tabik, et al. I wanted to try this paper and dataset out because I was originally a marine biology major before switching to computer science and doing machine learning, and I&#39;ve been wanting to take the tools I&#39;ve learned and apply it back into the field. For a quick ELI5 of what a coral is, corals are actually living animals that pack themselves into a skeleton, living as one giant body. These skeletons are then what we see in the ocean (and what&#39;s left after coral bleaching!) . The Paper . In this paper, they describe a problem for underwater identification of corals where the current methods are very unreliable and complicated because the datasets are unrealistic. These datasets provide texture-based images while images taken in practice, say by underwater vehicles, are the complete coral structure. For reference, here is a snippet from their paper: . . As we can see, the texture images are much closer than the structured images. . These images come from the RSMAS dataset linked here. With this dataset as a guide, the authors introduce a new dataset: StructureRSMAS. While RSMAS has 766 256 by 256 pixel images of the coral textures, StructureRSMAS contains images of a variety of size, with 409 total pictures. For this first post, we&#39;ll be focusing on their results from StructureRSMAS dataset. . We&#39;ll be focusing on the Structure Classifier in this article and the StructureRSMAS dataset . In the paper they also mention how the overall final structure of the models are. Essentially they have a pyramid of models that are run dependant on the model prior to it. See the visualization below: . . Their Experiment Design . When training on StructureRSMAS, the authors looked at three different architecture designs, three different number of training epochs, and three different batch sizes. Their work was done in TensorFlow, so there&#39;s ample opportunity to bring in some of the fastai functionalities. Here was their hyperparameters they tested (table from page 17): . . What they found through their experiments was that a ResNet 50 at 300 epochs and a batch size of 32 had the highest accuracy of 83.158% without image augmentation. From here, they tried a variety of image enhancements such as Debluring, Saliency, and Contrast and Brightness Enhancement. Using a Deblurring method they further increased the accuracy to 85%. Afterwards they tried a variety of image augmentations and found it did not improve the accuracy. The results of these experiments are the average of a five-fold Cross Validation on the data. Now that we know how it was set up, we can try fitting in fastai functionalities to beat this benchmark. . Bringing in fastai . With a benchmark to work off of let&#39;s see if we can apply the fastai framework here with two goals in mind: . Higher accuracy | Less time training | . First, let&#39;s grab the library: . from fastai2.vision.all import * . As this notebook can be run top-down in Jupyter, we&#39;ll also grab the dataset in-line . url = &#39;https://sci2s.ugr.es/sites/default/files/files/ComplementaryMaterial/CoralClassification/StructureRSMAS.zip&#39; . We can use wget to pull our data . !wget {url} -O coral.zip -q . And then extract the zip file with ZipFile . from zipfile import ZipFile with ZipFile(&#39;coral.zip&#39;, &#39;r&#39;) as zip_ref: zip_ref.extractall(&#39;coral&#39;) . Let&#39;s look at how they have their data structured: . path = Path(&#39;coral/StructureRSMAS&#39;) . path.ls()[:2] . (#2) [Path(&#39;coral/StructureRSMAS/APAL&#39;),Path(&#39;coral/StructureRSMAS/MMEA&#39;)] . We can see that each category is stored inside of its own folder, so let&#39;s build a DataBlock for this. (For those who are unfamilair with the new API, read my post here. . The DataBlock . For augmentation, we&#39;ll utilize a presizing method taught by Jeremy, along with some augmentation. This includes increasing the brightness and contrast, something that the authors found improved the results. When doing Pre-sizing, you&#39;d generally take an image that is large and resize it to a much smaller size through cropping (either randomly cropping the image or cropping at the center), and then I further shrink this image size down. What this allows is smaller or more uncommon features in the image have a chance to be fully scene to our network. This has an advantage when your input images are all a variety of sizes and shapes. . item_tfms = Resize(256) batch_tfms = [RandomResizedCrop(224), *aug_transforms(mult=1.0, do_flip=True, max_rotate=30.0, max_zoom=1.5, max_lighting=.8, max_warp=0.3, p_lighting=.9)] . block = DataBlock(blocks=(ImageBlock, CategoryBlock), splitter = RandomSplitter(), get_items=get_image_files, get_y=parent_label, item_tfms=item_tfms, batch_tfms=batch_tfms) . We&#39;ll build our DataLoaders using the same batch size too: . dls = block.dataloaders(path, bs=32) . Let&#39;s look at a batch . dls.show_batch() . Training, and what we will be doing differently . For their experiments they used 5 Folds for K-Fold Cross Validation, we&#39;ll recreate the process based on this notebook. We&#39;ll also use a few different image augmentations and Test Time Augmentation (TTA), the prior was not explored much and the latter was not used at all. TTA is explained further in the article. Also to note: as the dataset is extremely small we won&#39;t have a hold-out test set we evaluate on. . from sklearn.model_selection import StratifiedKFold . We&#39;ll get some setups to use scikit-learn&#39;s StratifiedKFold in the library, specifically our training images: . imgs = get_image_files(path) . Shuffle them around . random.shuffle(imgs) . And then grab their labels . lbls = [parent_label(im) for im in imgs] . We&#39;ll also be utilizing the progressive resizing technique, where we train initially on a smaller set of images before moving upwards to a larger size. We&#39;re doing this as our data comes from a variety of sized images, so this will be a good way to get the most out of our data. . Now you&#39;re probably confused about the difference between pre-sizing and progressive resizing. I&#39;ll try to explain the difference. Pre-sizing is where we initially make our image larger before applying a random crop of the image (such as 256x256 to 224x224). This can bring an opportunity for some smaller or finer details to show up more prominantly. . Progressive resizing is a technique where we start training at a small image size and then increase this image size while training. Here we&#39;ll start at an image size of 128x128 and then train on an image size of 224x224 afterwards . Now let&#39;s make a function to help us build our DataLoaders in such a way as to support progressive resizing . def get_dls(bs, size, val_idx): dblock = DataBlock(blocks=(ImageBlock, CategoryBlock), get_items=get_image_files, get_y=parent_label, splitter=IndexSplitter(val_idx), item_tfms = Resize(256), batch_tfms = [RandomResizedCrop(size), *aug_transforms(mult=1.0, do_flip=True, max_rotate=30.0, max_zoom=1.5, max_lighting=.8, max_warp=0.3, p_lighting=.9), Normalize.from_stats(*imagenet_stats)]) return dblock.dataloaders(path, bs=bs) . To use Stratified K-Fold Cross Validation in fastai, we&#39;ll use an IndexSplitter to pass it into the framework. Now from here our training loop will be setup to first train on 128x128 sized images for three epochs, followed by increase the size to 224x224 and train for six more. In most cases they will not run for this full time however as EarlyStopping is being used to cut-off training once the model stops improving. . From here we will employ &quot;Test Time Augmentation&quot; and report back the accuracy, which will then be averaged from all models. Test Time Augmentation is a technique where you also perform some augmentation on your test data, as it sounds like. In fastai this operates by making copies of your test images and augmenting them. By default it will make 3 copies and then these results are averaged. This has been shown to have the potential to further increase your accuracy. We&#39;ll take it for a test drive now: . Note, the output from training is not displayed as this takes a large amount of article space to run, I have summarized the results below this code block. | . val_pct = [] skf = StratifiedKFold(n_splits=5, shuffle=True) i = 0 for _, val_idx in skf.split(np.array(imgs), lbls): dls = get_dls(32, 128, val_idx) learn = cnn_learner(dls, resnet50, metrics=accuracy) learn.fine_tune(2, cbs=[EarlyStoppingCallback(monitor=&#39;accuracy&#39;)]) learn.dls = get_dls(32, 224, val_idx) learn.fine_tune(5, 1e-3, cbs=[EarlyStoppingCallback(monitor=&#39;accuracy&#39;)]) preds,targs = learn.tta() print(accuracy(preds, targs).item()) val_pct.append(accuracy(preds, targs).item()) i+=1 . Results . The results from our training were: . Fold 1: 82.9% | Fold 2: 89.0% | Fold 3: 89.0% | Fold 4: 90.2% | Fold 5: 90.1% | . All of these folds then further average to 88%, outperforming the 83% they found without augmentation, and the 85% used with augmentation. There&#39;s many little neat &quot;tricks&quot; the fastai library provides and each one can increase and further how your model performs. When we began this article there were two goals in mind, let&#39;s review them: . Decrease training time: The paper trained for 300 total epochs, we brought it down to 9 | . | Increase accuracy: The paper had an accuracy at best of 85%, we were able to boost it to 88%, with one instance where the accuracy was 90%. | Note: I did run a test with just Resizing and could match their baseline of ~83% | . | . In the next blog we&#39;ll take a look at the other ideas that were implemented in the paper and compare how different optimizers may perform on the data. .",
            "url": "https://muellerzr.github.io/fastblog/papers/2020/03/23/CoralID.html",
            "relUrl": "/papers/2020/03/23/CoralID.html",
            "date": " • Mar 23, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "The Idea of a Transform",
            "content": ". This blog is also a Jupyter notebook available to run from the top down. There will be code snippets that you can then run in any environment. In this section I will be posting what version of fastai2 and fastcore I am currently running at the time of writing this: . fastai2: 0.0.13 . | fastcore: 0.1.15 . | . . The DataBlock API Continued . This is part two of my series exploring the DataBlock API. If you have not read part one, fastai and the New DataBlock API, see here In it, we discussed the ideas of the DataBlock as a whole and how each of the lego-bricks can fit together to help solve some interesting problems. In this next blog, we&#39;ll be slowly diving into more complex ideas and uses with it, such as adjusting our y values inside of our get_y, dealing with classification data seperated by folders (and the splitters we can use) . Also, as a little note, this blog is not explaining the Transform class, this will come later . From here on we&#39;ll be focusing solely on generating the DataLoaders. Seperate blogs will be made about training the various models. Now, onto the code! As we&#39;re still Vision based, we&#39;ll use the vision sub-library: . from fastai2.vision.all import * . ImageWoof . ImageWoof is a subset of 10 dogs from ImageNet. The idea is that these 10 species of dogs are extremely similar, and so they&#39;re hard to classify from scratch. We won&#39;t care about that part today, let&#39;s go through and see how the data is formatted and apply the DataBlock. First let&#39;s grab the data: . path = untar_data(URLs.IMAGEWOOF) . Now if we take a look at the path first, we&#39;ll notice that we have train and val folders. The two ideas I&#39;ll be introducing with this dataset for splitting and labelling are GrandparentSplitter and parent_label . path.ls() . (#2) [Path(&#39;/root/.fastai/data/imagewoof2/train&#39;),Path(&#39;/root/.fastai/data/imagewoof2/val&#39;)] . What do each of these do? I&#39;ll go into heavy detail on fastai&#39;s splitters and labellers but GrandparentSplitter operates with the assumption our data is split like ImageNet, where we have training data in a training folder and validation data into a validation folder such as here. Let&#39;s make a splitter now by passing in the name of the training folder and the validation folder: . splitter = GrandparentSplitter(train_name=&#39;train&#39;, valid_name=&#39;val&#39;) . Let&#39;s look at some splits. First we&#39;ll grab our list of images then use our GrandparentSplitter to seperate out two indicies for us, which we&#39;ll then look at to make sure it&#39;s working properly . items = get_image_files(path) . splits = splitter(items) . splits[0][0], splits[1][0] . (0, 9025) . Now let&#39;s look at images 0 and 9025: . items[0], items[9025] . (Path(&#39;/root/.fastai/data/imagewoof2/train/n02087394/n02087394_15618.JPEG&#39;), Path(&#39;/root/.fastai/data/imagewoof2/val/n02087394/n02087394_13440.JPEG&#39;)) . And we can see that the folders line up! . Now that we have the splitter out of the way, we need a way to get our classes! But what do they look like? We&#39;ll look inside the train folder at some of the images for some examples: . train_p = path/&#39;train&#39; . train_p.ls()[:3] . (#3) [Path(&#39;/root/.fastai/data/imagewoof2/train/n02087394&#39;),Path(&#39;/root/.fastai/data/imagewoof2/train/n02115641&#39;),Path(&#39;/root/.fastai/data/imagewoof2/train/n02111889&#39;)] . items = get_image_files(train_p)[:5]; items . (#5) [Path(&#39;/root/.fastai/data/imagewoof2/train/n02087394/n02087394_15618.JPEG&#39;),Path(&#39;/root/.fastai/data/imagewoof2/train/n02087394/n02087394_6198.JPEG&#39;),Path(&#39;/root/.fastai/data/imagewoof2/train/n02087394/n02087394_2253.JPEG&#39;),Path(&#39;/root/.fastai/data/imagewoof2/train/n02087394/n02087394_7428.JPEG&#39;),Path(&#39;/root/.fastai/data/imagewoof2/train/n02087394/n02087394_28267.JPEG&#39;)] . We can visualize this folder setup like so: . . What this tells us is that our labels are in the folder one level above the actual image, or in the parent folder (if we consider it like a tree). As such, we can use the parent_label function to extract it! Let&#39;s look: . labeller = parent_label . labeller(items[0]) . &#39;n02087394&#39; . From here we can simply build our DataBlock similar to the last post: . blocks = (ImageBlock, CategoryBlock) item_tfms=[Resize(224)] batch_tfms=[Normalize.from_stats(*imagenet_stats)] . block = DataBlock(blocks=blocks, get_items=get_image_files, get_y=parent_label, item_tfms=item_tfms, batch_tfms=batch_tfms) . And make our DataLoaders: . dls = block.dataloaders(path, bs=64) . To make sure it all worked out, let&#39;s look at a batch: . dls.show_batch(max_n=3) . The idea of a transform . Now we&#39;re still going to use the ImageWoof dataset here, but I want to introduce you to the concept of a transform. From an outside perspective and what we&#39;ve seen so far, this is normally limited to what we would call &quot;augmentation.&quot; With the new fastai this is no longer the case. Instead, let&#39;s think of a transform as &quot;any modification we can apply to our data at any point in time.&quot; . But what does that really mean? What is a transform? A function! Any transform can be written out as a simple function that we pass in at any moment. . What do I mean by this though? Let&#39;s take a look at those labels again. If we notice, we see bits like: . labeller(items[0]), labeller(items[1200]) . (&#39;n02087394&#39;, &#39;n02115641&#39;) . But that has no actual meaning to us (or anyone else reading to what we are doing). Let&#39;s use a transform that will change this into something readable. . First we&#39;ll build a dictionary that keeps track of what each original class name means: . lbl_dict = dict(n02086240= &#39;Shih-Tzu&#39;, n02087394= &#39;Rhodesian ridgeback&#39;, n02088364= &#39;Beagle&#39;, n02089973= &#39;English foxhound&#39;, n02093754= &#39;Australian terrier&#39;, n02096294= &#39;Border terrier&#39;, n02099601= &#39;Golden retriever&#39;, n02105641= &#39;Old English sheepdog&#39;, n02111889= &#39;Samoyed&#39;, n02115641= &#39;Dingo&#39; ) . Now to use this as a function, we need a way to look into the dictionary with any raw input and return back our string. This can be done via the __getitem__ function: . lbl_dict.__getitem__(labeller(items[0])) . &#39;Rhodesian ridgeback&#39; . But what is __getitem__? It&#39;s a generic python function in classes that will look up objects via a key. In our case, our object is a dictionary and so we can pass in a key value to use (such as n02105641) and it will know to return back &quot;Old English sheepdog&quot; when called . Looks readable enough now, right? So where do I put this into the API. We can stack these mini-transforms anywhere we&#39;d like them applied. For instance here, we want it done on our get_y, but after parent_label has been applied. Let&#39;s do that: . block = DataBlock(blocks=blocks, get_items=get_image_files, get_y=[parent_label, lbl_dict.__getitem__], item_tfms=item_tfms, batch_tfms=batch_tfms) . dls = block.dataloaders(path, bs=64) . dls.show_batch(max_n=3) . Awesome! It worked, and that was super simple. Does the order matter here though? Let&#39;s try reversing it: . block = DataBlock(blocks=blocks, get_items=get_image_files, get_y=[lbl_dict.__getitem__, parent_label], item_tfms=item_tfms, batch_tfms=batch_tfms) . dls = block.dataloaders(path, bs=64) . . Oh no, I got an error! What is it telling me? That I was passing in the full image path to the dictionary before we extracted the parent_label, so order does matter in how you place these functions! Further, these functions can go in any of the building blocks for the DataBlock except during data augmentation (as these require special modifications we&#39;ll look at later). .",
            "url": "https://muellerzr.github.io/fastblog/datablock/2020/03/22/TransformFunctions.html",
            "relUrl": "/datablock/2020/03/22/TransformFunctions.html",
            "date": " • Mar 22, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "fastai and the New DataBlock API",
            "content": ". This blog is also a Jupyter notebook available to run from the top down. There will be code snippets that you can then run in any environment. In this section I will be posting what version of fastai2 and fastcore I am currently running at the time of writing this: . fastai2: 0.0.13 . | fastcore: 0.1.15 . | . . What is the DataBlock API? . The DataBlock API is certainly nothing new to fastai. It was here in a lesser form in the previous version, and the start of an idea. This idea was: &quot;How do we let the users of the fastai library build DataLoaders in a way that is simple enough that someone with minimal coding knowledge could get the hang of it, but be advanced enough to allow for exploration.&quot; The old version was a struggle to do this from a high-level API standpoint, as you were very limited in what you could do: variables must be passed in a particular order, the error checking wasn&#39;t very explanatory (to those unaccustomed to debugging issues), and while the general idea seemed to flow, sometimes it didn&#39;t quite work well enough. For our first example, we&#39;ll look at the Pets dataset and compare it from fastai version 1 to fastai version 2 . The DataBlock itself is built on &quot;building blocks&quot;, think of them as legos. (For more information see fastai: A Layered API for Deep Learning) They can go in any order but together they&#39;ll always build something. Our lego bricks go by these general names: . blocks | get_items | get_x/get_y | getters | splitter | item_tfms | batch_tfms | . We&#39;ll be exploring each one more closely throughout this series, so we won&#39;t hit on all of them today . Importing from the library . The library itself is still split up into modules, similar to the first version where we have Vision, Text, and Tabular. To import from these libraries, we&#39;ll be calling their .all files. Our example problem for today will involve Computer Vision so we will call from the .vision library . from fastai2.vision.all import * . Pets . Pets is a dataset in which you try to identify one of 37 different species of cats and dogs. To get the dataset, we&#39;re going to use functions very familiar to those that used fastai version 1. We&#39;ll use untar_data to grab the dataset we want. In our case, the Pets dataset lives in URLs.PETS . URLs.PETS . &#39;https://s3.amazonaws.com/fast-ai-imageclas/oxford-iiit-pet.tgz&#39; . path = untar_data(URLs.PETS) . Looking at the dataset . When starting to look at adapting the API for a particular problem, we need to know just how the data is stored. We have an image problem here so we can use the get_image_files function to go grab all the file locations of our images and we can look at the data! . fnames = get_image_files(path/&#39;images&#39;) . To investigate how the files are named and where they are located, let&#39;s look at the first one: . fnames[0] . Path(&#39;/root/.fastai/data/oxford-iiit-pet/images/pug_119.jpg&#39;) . Now as get_image_files grabs the filename of our x for us, we don&#39;t need to include our get_x here (which defaults to None) as we just want to use this filepath! Now onto our file paths and how they relate to our labels. If we look at our returned path, this particular image has the class of pug. . Where do I see that? . Here: Path(&#39;/root/.fastai/data/oxford-iiit-pet/images/pug_119.jpg&#39;) . All the images follow this same format, and we can use a Regular Expression: to get it out. In our case, it would look something like so: . pat = r&#39;([^/]+)_ d+.*$&#39; . How do we know it worked? Let&#39;s apply it to the first file path real quick with re.search where we pass in the pattern followed by an item to try and find a match in the first group (set of matches) with a Regular Expression . re.search(pat, str(fnames[0])).group(1) . &#39;pug&#39; . We have our label! So what parts do we have so far? We know how to grab our items (get_items and get_x), our labels (get_y), what&#39;s left? Well, we&#39;ll want some way to split our data and our data augmentation. Let&#39;s focus on the prior. . Splitting and Augmentation . Any time we train a model, the data must be split between a training and validation dataset. The general idea is that the training dataset is what the model adjusts and fits its weights to, while the validation set is for us to understand how the model is performing. fastai2 has a family of split functions to look at that will slowly get covered throughout these blogs. For today we&#39;ll randomly split our data so 80% goes into our training set and 20% goes into the validation. We can utilize RandomSplitter to do so by passing in a percentage to split by, and optionally a seed as well to get the same validation split on multiple runs . splitter = RandomSplitter(valid_pct=0.2, seed=42) . How is this splitter applied? The splitter itself is a function that we can then apply over some set of data or numbers (an array). It works off of indexes. What does that look like? Let&#39;s see: . splitter(fnames) . ((#5912) [5643,5317,5806,3460,613,5456,2968,3741,10,4908...], (#1478) [4512,4290,5770,706,2200,4320,6450,501,1290,6435...]) . That doesn&#39;t look like filenames! Correct, instead its the location in our list of filenames and what group it belongs to. What this special looking list (or L) also tells us is how many items are in each list. In this example, the first (which is our training data) has 5,912 samples and the second (which is our validation) contains 1,478 samples. . Now let&#39;s move onto the augmentation. As noted earlier, there are two kinds: item_tfms and batch_tfms. Each do what it sounds like: an item transform is applied on an individual item basis, and a batch transform is applied over each batch of data. The role of the item transform is to prepare everything for a batch level (and to apply any specific item transformations you need), and the batch transform is to further apply any augmentations on the batch level efficently (normalization of your data also happens on a batch level). One of the biggest differences between the two though is where each is done. Item transforms are done on the CPU while batch transforms are performed on the GPU. . Now that we know this, let&#39;s build a basic transformation pipeline that looks something like so: . Resize our images to a fixed size (224x224 pixels) | After they are batched together, choose a quick basic augmentation function | Normalize all of our image data | Let&#39;s build it! . item_tfms = [Resize(224, method=&#39;crop&#39;)] batch_tfms=[*aug_transforms(size=256), Normalize.from_stats(*imagenet_stats)] . Woah, woah, woah, what in the world is this aug_transforms thing you just showed me I hear you ask? It runs a series of augmentations similar to the get_transforms() from version 1. The entire list is quite exhaustive and we&#39;ll discuss it in a later blog, but for now know we can pass in an image size to resize our images to (we&#39;ll make our images a bit larger, doing 256x256). . Alright, we know how we want to get our data, how to label it, split it, and augment it, what&#39;s left? That block bit I mentioned before. . The Block . Block&#39;s are used to help nest transforms inside of pre-defined problem domains. . Lazy-man&#39;s explaination? . If it&#39;s an image problem I can tell the library to use Pillow without explicitly saying it, or if we have a Bounding Box problem I can tell the DataBlock to expect two coordinates for boxes and to apply the transforms for points, again without explicitly saying these transforms. . What will we use today? Well let&#39;s think about our problem: we are using an image for our x, and our labels (or y&#39;s) are some category. Is there blocks for this? Yes! And they&#39;re labeled ImageBlock and CategoryBlock! Remember how I said it just &quot;made more sense?&quot; This is a direct example. Let&#39;s define them: . blocks = (ImageBlock, CategoryBlock) . Now let&#39;s build this DataBlock thing already! . Alright we have all the pieces now, let&#39;s see how they fit together. We&#39;ll all wrap them up in a nice little package of a DataBlock. Think of the DataBlock as a list of instructions to do when we&#39;re building batches and our DataLoaders. It doesn&#39;t need any items explicitly to be done, and instead is a blueprint of how to operate. We define it like so: . block = DataBlock(blocks=blocks, get_items=get_image_files, get_y=RegexLabeller(pat), splitter=splitter, item_tfms=item_tfms, batch_tfms=batch_tfms) . Once we have our DataBlock, we can build some DataLoaders off of it. To do so we simply pass in a source for our data that our DataBlock would be expecting, specifically our get_x and get_y, so we&#39;ll follow the same idea we did above to get our filenames and pass in a path to the folder we want to use along with a batch size: . dls = block.dataloaders(path, bs=64) . While it&#39;s a bit long, you can understand why we had to define everything the way that we did. If you&#39;re used to how fastai v1 looked with the ImageDataBunch.from_x, well this is stil here too: . dls = ImageDataLoaders.from_name_re(path, fnames, pat, item_tfms=item_tfms, batch_tfms=batch_tfms, bs=64) . I&#39;m personally a much larger fan of the first example, and if you&#39;re planning on using the library quite a bit you should get used to it more as well! This blog series will be focusing on that nomenclature specifically. To make sure everything looks okay and we like our augmentation we can show a batch of images from our DataLoader. It&#39;s as simple as: . dls.show_batch() . Fitting a Model . Now from here everything looks and behaves exactly how it did in fastai version 1: . Define a Learner | Find a learning rate | Fit | We&#39;ll quickly see that fastai2 has a quick function for transfer learning problems like we are doing, but first let&#39;s build the Learner. This will use cnn_learner, as we are doing transfer learning, and we&#39;ll tell the function to use a resnet34 architecture with accuracy metrics . learn = cnn_learner(dls, resnet34, metrics=accuracy) . Now normally we would do learn.lr_find() and find a learning rate, but with the new library, we now have a fine_tune() function we can use instead specifically designed for transfer learning scenarios. It runs a specified number of epochs (the number of times we fully go through the dataset) on a frozen model (where all but the last layer&#39;s weights are not trainable) and then the last few will be on an unfrozen model (where all weights are trainable again). When just passing in one set of epochs, like below, it will run frozen for one and unfrozen for the rest. Let&#39;s try it! . learn.fine_tune(3) . epoch train_loss valid_loss accuracy time . 0 | 1.488222 | 0.331919 | 0.893099 | 00:42 | . epoch train_loss valid_loss accuracy time . 0 | 0.471458 | 0.363768 | 0.890392 | 00:43 | . 1 | 0.368975 | 0.250430 | 0.926252 | 00:43 | . 2 | 0.205113 | 0.215602 | 0.935047 | 00:44 | . As we can see we did pretty goood just with this default! Generally when the accuracy is this high, we want to turn instead to error_rate for our metric, as this would show ~6.5% and is a better comparison when it gets very fine tuned. . But that&#39;s it for this first introduction! We looked at how the Pets dataset can be loaded into the new high-level DataBlock API, and what it&#39;s built with. In the next blog we will be exploring more variations with the DataBlock as we get more and more creative. Thanks for reading! .",
            "url": "https://muellerzr.github.io/fastblog/datablock/2020/03/21/DataBlockAPI.html",
            "relUrl": "/datablock/2020/03/21/DataBlockAPI.html",
            "date": " • Mar 21, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "I am currently an undergraduate student at the University of West Florida, with a graduation date of Fall 2022. Afterwards, I plan on going to Graduate School to get my Master’s Degree in Data Science . At the University I facilitate and teach the Fast.AI classes to Undergraduates and Graduates, with Jeremy’s notes being my forefront go-to. Currently, the Practical Deep Learning course is happening, with plans to slowly integrate more to help teach students the benefits of knowing Deep Learning in the modern world. . Contact me . muellerzr@gmail.com .",
          "url": "https://muellerzr.github.io/fastblog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

}